{"version":3,"sources":["billboard-reflection/shaders/ShaderHelpers.js","billboard-reflection/shaders/billboard_reflection_shader_functions.js","billboard-reflection/BillboardReflection.js","demo/App.js","index.js"],"names":["unrollLoopPattern","loopReplacer","match","start","end","snippet","string","i","parseInt","replace","billboardVarying","billboardVertexCode","computeBillboardReflectionFunction","billboard_lights_fragment_maps","createBillboardFragmentUniforms","billboardCount","billboardTextureCount","createBillboardReflectionsFunctions","BillboardReflection","mesh","options","billboard","this","createFromTextureAndMatrix","material","map","matrixWorld","opacity","Object","defineProperty","get","visible","set","value","color","texture","rayFalloff","THREE","push","shader","roughnessMapBlur","roughnessMapBlurIntensity","roughness","undefined","envMapIntensity","length","allBillboardTextures","billboardTextures","Array","from","Set","billboardTexturesIndices","indexOf","billboardReflectionsFunctions","RegExp","defines","REFLECTION_ROUGHNESS_BLUR","roughnessMap","REFLECTION_ROUGHNESS_MAP_BLUR_INTENSITY","toFixed","uniforms","billboardReflections","vertexShader","lights_fragment_maps","fragmentShader","Controls","controls","useRef","useThree","camera","gl","scene","position","y","background","environment","useFrame","current","update","ref","args","domElement","enablePan","enableDamping","dampingFactor","rotateSpeed","Part","nodes","useLoader","GLTFLoader","billboard2","ground","billboardReflection","roughnessBlur","speed","rotation","x","Math","PI","sin","Date","now","z","cos","abs","renderTarget","pmremGenerator","PMREMGenerator","compileEquirectangularShader","useControls","folder","min","max","step","metalness","normalScale","onChange","_roughnessMap","needsUpdate","imageName","RGBELoader","load","tex","dispose","envMap","fromEquirectangular","minFilter","LinearFilter","colorPatternBillboard","reflection","_reflection","color2","label","setStyle","threejsBillboard","visible2","opacity2","reflection2","reflectionColorMultiplier2","reflectionColorMultiplier","rayFalloff2","collapsed","useEffect","create","onBeforeCompile","enableReflection","billboardMaterial","MeshBasicMaterial","side","DoubleSide","transparent","depthWrite","billboard2Material","Vector2","scale","App","Stats","intensity","fallback","Environment","files","path","multisampling","luminanceThreshold","width","edgeDetectionMode","EdgeDetectionMode","DEPTH","extend","OrbitControls","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.5bedd29a.chunk.js","sourcesContent":["// workaround to also unroll loops in onBeforeCompile\r\n\r\n// from THREE.WebGLProgram\r\nconst unrollLoopPattern = /#pragma unroll_loop_start\\s+for\\s*\\(\\s*int\\s+i\\s*=\\s*(\\d+)\\s*;\\s*i\\s*<\\s*(\\d+)\\s*;\\s*i\\s*\\+\\+\\s*\\)\\s*{([\\s\\S]+?)}\\s+#pragma unroll_loop_end/g;\r\n\r\n// from THREE.WebGLProgram\r\nfunction loopReplacer(match, start, end, snippet) {\r\n\r\n    let string = ''\r\n\r\n    for (let i = parseInt(start); i < parseInt(end); i++) {\r\n\r\n        string += snippet\r\n            .replace(/\\[\\s*i\\s*\\]/g, '[ ' + i + ' ]')\r\n            .replace(/UNROLLED_LOOP_INDEX/g, i)\r\n\r\n    }\r\n\r\n    return string\r\n\r\n}\r\n\r\nexport function unrollLoops(string) {\r\n\r\n    return string\r\n        .replace(unrollLoopPattern, loopReplacer)\r\n\r\n}\r\n\r\nexport const mip_map_level = /* glsl */`\r\n// source: https://stackoverflow.com/a/24390149/7626841\r\nfloat mip_map_level(in vec2 texture_coordinate){\r\n  vec2  dx_vtc = dFdx(texture_coordinate);\r\n  vec2  dy_vtc = dFdy(texture_coordinate);\r\n  \r\n  float delta_max_sqr = max(dot(dx_vtc, dx_vtc), dot(dy_vtc, dy_vtc));\r\n\r\n  return 0.5 * log2(delta_max_sqr);\r\n}`\r\n\r\n// source: https://github.com/tobspr/GLSL-Color-Spaces/blob/master/ColorSpaces.inc.glsl#L81\r\n// Converts a srgb color to a rgb color (approximated, but fast)\r\nexport const srgb_to_rgb_approx = /* glsl */`\r\nconst float SRGB_INVERSE_GAMMA = 2.2;\r\n\r\nvec3 srgb_to_rgb_approx(vec3 srgb) {\r\n    return pow(srgb, vec3(SRGB_INVERSE_GAMMA));\r\n}`","import { mip_map_level, srgb_to_rgb_approx, unrollLoops } from \"./ShaderHelpers\"\r\n\r\n// varying variables\r\nconst billboardVarying = /* glsl */`\r\nvarying vec3 vPosition;\r\nvarying vec3 cameraDirection;\r\n`\r\n\r\n// uniforms required for the fragment shader\r\nconst billboardFragmentUniforms = /* glsl */`\r\nuniform sampler2D billboardTextures[BILLBOARD_TEXTURE_COUNT];\r\n\r\nstruct BillboardReflection {\r\n  mat4 matrixWorld;\r\n  float rayFalloff;\r\n  vec3 color;\r\n  float opacity;\r\n};\r\n\r\nuniform BillboardReflection billboardReflections[BILLBOARD_COUNT];\r\n`\r\n\r\n// vertex shader code to assign values to the varying variables\r\nconst billboardVertexCode = /* glsl */`\r\nvPosition = (modelMatrix * vec4(position, 1.)).xyz;\r\ncameraDirection = vPosition - cameraPosition;\r\n`\r\n\r\n// billboard reflection algorithm source: https://kola.opus.hbz-nrw.de/opus45-kola/frontdoor/deliver/index/docId/908/file/BA_GuidoSchmidt.pdf\r\n\r\n// intersect triangle function\r\nconst intersectTriangleFunction = /* glsl */`\r\nvec3 intersectTriangle(vec3 rayOrig, vec3 rayDir, vec3 vector0, vec3 vector1, vec3 vector2){\r\n      float u, v, t;\r\n      vec3 e0, e1;\r\n\r\n      float det, invDet;\r\n\r\n      e0 = vector1 - vector0;\r\n      e1 = vector2 - vector0;\r\n\r\n      vec3 pVec = cross(rayDir, e1);\r\n\r\n      det = dot(e0, pVec);\r\n      invDet = 1. / det;\r\n\r\n      vec3 tVec = rayOrig - vector0;\r\n\r\n      u = dot(tVec, pVec) * invDet;\r\n\r\n      vec3 qVec = cross(tVec, e0);\r\n\r\n      v = dot(rayDir, qVec) * invDet;\r\n\r\n      t = dot(e1, qVec) * invDet;\r\n\r\n      return vec3(u, v, t);\r\n    }\r\n`\r\n\r\n// compute reflection for single billboard\r\nconst computeBillboardReflectionFunction = /* glsl */`\r\n${mip_map_level}\r\n${srgb_to_rgb_approx}\r\n\r\n${intersectTriangleFunction}\r\n\r\nvec4 computeBillboardReflection(vec3 wPos, vec3 wReflectVec, inout float shortestOpaqueBillboardDistance, float roughnessValue,\r\n  mat4 matrixWorld, sampler2D tBillboard, vec3 color, float rayFalloff, float opacity){\r\n  \r\n  vec4 reflectClr = vec4(0);\r\n  \r\n  vec3 vector0 = vec3( 1.,  0.,  1.);\r\n  vec3 vector1 = vec3(-1.,  0., -1.);\r\n  vec3 vector2 = vec3(-1.,  0.,  1.);\r\n\r\n  vector0 = (matrixWorld * vec4(vector0, 1.)).xyz;\r\n  vector1 = (matrixWorld * vec4(vector1, 1.)).xyz;\r\n  vector2 = (matrixWorld * vec4(vector2, 1.)).xyz;\r\n\r\n  vec3 uvt = intersectTriangle(wPos, wReflectVec, vector2, vector0, vector1);\r\n\r\n  // check if the reflecting billboard's distance is higher than the current lowest distance of an opaque billboard\r\n  if(shortestOpaqueBillboardDistance <= uvt.z){\r\n    // return no reflection\r\n    return reflectClr;\r\n  }\r\n\r\n  // check if the reflected ray hit a billboard\r\n  if(uvt.x > 0. && uvt.x < 1. &&    uvt.y > 0. && uvt.y < 1.){\r\n    if(uvt.z <= 0.001){\r\n      return reflectClr;\r\n    }\r\n\r\n    // get the reflected color\r\n    #ifdef REFLECTION_ROUGHNESS_BLUR\r\n      ivec2 texSize = textureSize(tBillboard, 0);\r\n      float mip = mip_map_level(uvt.xy * float(texSize));\r\n\r\n      float pixels = float(max(texSize.x, texSize.y));\r\n      pixels *= pixels;\r\n\r\n      float scale = log2(pixels) * REFLECTION_ROUGHNESS_MAP_BLUR_INTENSITY;\r\n\r\n      vec4 reflectedBillboardClr = textureLod(tBillboard, uvt.xy, max(mip, roughnessValue * scale));\r\n    #else\r\n      vec4 reflectedBillboardClr = texture(tBillboard, uvt.xy);\r\n    #endif\r\n    \r\n    if(opacity != 1.){\r\n      reflectedBillboardClr.a *= sqrt(opacity);\r\n    }\r\n\r\n    // make the ray's intensity fall off by distance to prevent artifacts (e.g. reflection visible behind wall)\r\n    if(rayFalloff != 0.){\r\n      float rayToCameraDistance = distance(cameraPosition, wPos);\r\n\r\n      reflectedBillboardClr.a *= min(1., 1. / (rayToCameraDistance * rayFalloff));\r\n    }\r\n    \r\n    if(reflectedBillboardClr.a == 1.){\r\n      shortestOpaqueBillboardDistance = uvt.z;\r\n    }\r\n\r\n    // final reflected color\r\n    reflectClr = vec4(\r\n      srgb_to_rgb_approx(reflectedBillboardClr.rgb) * color, 1.\r\n    )\r\n    * reflectedBillboardClr.a * (1. - roughnessValue * roughnessValue);\r\n  }\r\n\r\n  return reflectClr;\r\n}\r\n`\r\n\r\n// compute reflections for all billboards\r\nconst computeAllBillboardReflectionsFunction = /* glsl */`\r\nvec4 computeAllBillboardReflections(vec3 wPos, vec3 wReflectVec, float roughnessValue, float envMapIntensity){\r\n      vec4 reflectClr = vec4(0.);\r\n      \r\n      roughnessValue = clamp(roughnessValue, 0., 1.);\r\n\r\n      // inout parameter of the billboardReflection function to take care of overlapping opaque billboards\r\n      float shortestOpaqueBillboardDistance = 3.402823466e+38; // FLT_MAX\r\n\r\n      vec4 currentBillboardReflectClr;\r\n\r\n      // go through each billboard\r\n      #pragma unroll_loop_start\r\n      for(int i = 0; i < BILLBOARD_COUNT; i++){\r\n\r\n        // skip hidden billboards\r\n        if(billboardReflections[i].opacity != 0.){\r\n          currentBillboardReflectClr = computeBillboardReflection(\r\n            wPos, wReflectVec, shortestOpaqueBillboardDistance, roughnessValue,\r\n            billboardReflections[i].matrixWorld, billboardTextures[i], billboardReflections[i].color, billboardReflections[i].rayFalloff,\r\n            billboardReflections[i].opacity\r\n          );\r\n\r\n          // blend the reflected colors, if the current billboard was opaque, then reflectClr is equal to currentBillboardReflectClr\r\n          reflectClr = mix(reflectClr, currentBillboardReflectClr, currentBillboardReflectClr.a);\r\n        }\r\n        \r\n      }\r\n      #pragma unroll_loop_end\r\n\r\n      return reflectClr * envMapIntensity;\r\n    }\r\n`\r\n\r\n// modified lights_fragment_maps shader to add billboard reflections along with indirect environment irradiance\r\nconst billboard_lights_fragment_maps = /* glsl */`\r\n#if defined( RE_IndirectDiffuse )\r\n\t#ifdef USE_LIGHTMAP\r\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\r\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\r\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\r\n\t\t\tlightMapIrradiance *= PI; // factor of PI should not be present; included here to prevent breakage\r\n\t\t#endif\r\n\t\tirradiance += lightMapIrradiance;\r\n\t#endif\r\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\r\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( /*lightProbe,*/ geometry, maxMipLevel );\r\n\t#endif\r\n#endif\r\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\r\n  vec3 indirectRadiance = getLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\r\n\r\n  vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\r\n  \r\n  vec3 reflectVec = reflect(cameraDirection, worldNormal);\r\n  vec4 billboardClr = computeAllBillboardReflections(vPosition, reflectVec, roughnessFactor, envMapIntensity);\r\n\r\n  radiance = mix(indirectRadiance, billboardClr.rgb, billboardClr.a);\r\n\r\n\t#ifdef CLEARCOAT\r\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\r\n\t#endif\r\n#else\r\n  vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\r\n  \r\n  vec3 reflectVec = reflect(cameraDirection, worldNormal);\r\n  vec4 billboardClr = computeAllBillboardReflections(vPosition, reflectVec, roughnessFactor, 1.);\r\n\r\n  radiance = billboardClr.rgb;\r\n#endif\r\n`\r\n\r\n// functions for creating shaders\r\n\r\nconst createBillboardFragmentUniforms = (billboardCount, billboardTextureCount) => {\r\n  return billboardFragmentUniforms\r\n    .replace(/BILLBOARD_COUNT/g, billboardCount)\r\n    .replace(/BILLBOARD_TEXTURE_COUNT/g, billboardTextureCount)\r\n}\r\n\r\n// main billboard reflections function, needs to be created through a function as the count of the billboards needs to be known before the billboard loop will be unrolled\r\nconst createBillboardReflectionsFunctions = billboardCount => unrollLoops(\r\n  computeBillboardReflectionFunction +\r\n  computeAllBillboardReflectionsFunction.replace(/BILLBOARD_COUNT/g, billboardCount)\r\n)\r\n\r\nexport { billboardVarying, billboardVertexCode, billboard_lights_fragment_maps, createBillboardFragmentUniforms, createBillboardReflectionsFunctions }","import * as THREE from \"three\"\r\nimport { billboardVarying, createBillboardFragmentUniforms, billboardVertexCode, createBillboardReflectionsFunctions, billboard_lights_fragment_maps }\r\n    from \"./shaders/billboard_reflection_shader_functions\"\r\n\r\nexport default class BillboardReflection {\r\n    #billboards = []\r\n\r\n    /**\r\n     * Adds a new reflection for the given mesh\r\n     * @param {*} mesh mesh that will be reflected\r\n     * @param {*} [options] settings to tweak the reflection\r\n     * @returns reflection options object\r\n     */\r\n    create(mesh, options = {}) {\r\n        let billboard = this.createFromTextureAndMatrix(mesh.material.map, mesh.matrixWorld, options)\r\n\r\n        // if no opacity was specified, always use the underlying mesh's opacity (0 in case the mesh or its material is not visible)\r\n        if (typeof options.opacity === \"undefined\") {\r\n            Object.defineProperty(billboard, \"opacity\", {\r\n                get() {\r\n                    return (mesh.visible && mesh.material.visible && billboard.visible) ? mesh.material.opacity : 0\r\n                }\r\n            })\r\n        } else {\r\n            let opacity = billboard.opacity\r\n\r\n            Object.defineProperty(billboard, \"opacity\", {\r\n                set(value) {\r\n                    opacity = value\r\n                },\r\n                get() {\r\n                    return billboard.visible ? opacity : 0\r\n                }\r\n            })\r\n        }\r\n\r\n        if (typeof options.color === \"undefined\") {\r\n            Object.defineProperty(billboard, \"color\", {\r\n                get() {\r\n                    return mesh.material.color\r\n                }\r\n            })\r\n        }\r\n\r\n        return billboard\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {*} texture texture of the reflection\r\n     * @param {*} matrixWorld matrixWorld of the billboard\r\n     * @param {*} [options] settings to tweak the reflection\r\n     * @returns reflection options object\r\n     */\r\n    createFromTextureAndMatrix(texture, matrixWorld, { rayFalloff = 0, color = new THREE.Color(), opacity = 1, visible = true } = {}) {\r\n        const billboard = {\r\n            texture,\r\n            matrixWorld,\r\n            rayFalloff,\r\n            color,\r\n            opacity,\r\n            visible\r\n        }\r\n\r\n        this.#billboards.push(billboard)\r\n\r\n        return billboard\r\n    }\r\n\r\n    /**\r\n     * Enables billboard reflections for a given shader\r\n     * @param {*} shader shader of the given material, usually acquired through THREE.Material.onBeforeCompile\r\n     * @param {*} [options] settings to tweak the reflection\r\n     * which results in better results for more contrasty roughness maps\r\n     */\r\n    enableReflection(shader, { roughnessMapBlur = true, roughnessMapBlurIntensity = 0.85, roughness = undefined, envMapIntensity = undefined } = {}) {\r\n        const billboardCount = this.#billboards.length\r\n\r\n        if (billboardCount === 0) return\r\n\r\n        const allBillboardTextures = this.#billboards.map(billboard => billboard.texture)\r\n        const billboardTextures = Array.from(new Set(allBillboardTextures))\r\n        const billboardTextureCount = billboardTextures.length\r\n        const billboardTexturesIndices = this.#billboards.map(billboard => billboardTextures.indexOf(billboard.texture))\r\n\r\n        let billboardReflectionsFunctions = createBillboardReflectionsFunctions(billboardCount)\r\n\r\n        // textures are stored in a seperate array that can have a smaller size than the billboard count\r\n        // due to multiple billboards using the same texture for example\r\n        // replace the incrementing texture indices in the shader with their actual index in the billboardTextures array uniform\r\n        for (let i = 0; i < billboardCount; i++) {\r\n            billboardReflectionsFunctions = billboardReflectionsFunctions\r\n                .replace(new RegExp(\"billboardTextures\\\\[\\\\s\" + i + \"\\\\s\\\\]\", \"g\"), \"billboardTextures[ \" + billboardTexturesIndices[i] + \" ]\")\r\n        }\r\n\r\n        // defines\r\n        // enable reflection blur only if not toggled off and when the shader has a roughness map\r\n        shader.defines.REFLECTION_ROUGHNESS_BLUR = roughnessMapBlur && shader.roughnessMap\r\n        shader.defines.REFLECTION_ROUGHNESS_MAP_BLUR_INTENSITY = roughnessMapBlurIntensity.toFixed(5)\r\n\r\n        // uniforms\r\n        shader.uniforms.billboardTextures = { value: billboardTextures }\r\n        shader.uniforms.billboardReflections = { value: Array.from(this.#billboards) }\r\n\r\n        // vertex shader\r\n        shader.vertexShader = shader.vertexShader\r\n            .replace(\r\n                \"#include <common>\",\r\n                \"#include <common>\\n\" + billboardVarying\r\n            )\r\n            .replace(\r\n                \"#include <project_vertex>\",\r\n                \"#include <project_vertex>\\n\" + billboardVertexCode\r\n            )\r\n\r\n        // fragment shader\r\n        let lights_fragment_maps = typeof roughness === \"number\" ?\r\n            billboard_lights_fragment_maps.replace(/roughnessFactor/g, roughness.toFixed(5))\r\n            :\r\n            billboard_lights_fragment_maps\r\n\r\n        if (typeof envMapIntensity === \"number\") {\r\n            lights_fragment_maps = lights_fragment_maps.replace(/envMapIntensity/g, envMapIntensity.toFixed(5))\r\n        }\r\n\r\n        shader.fragmentShader = shader.fragmentShader\r\n            .replace(\r\n                \"#include <common>\",\r\n                \"#include <common>\\n\" + billboardVarying + \"\\n\" + createBillboardFragmentUniforms(billboardCount, billboardTextureCount)\r\n            )\r\n            .replace(\r\n                \"#include <bsdfs>\",\r\n                \"#include <bsdfs>\\n\" + billboardReflectionsFunctions\r\n            )\r\n            .replace(\r\n                \"#include <lights_fragment_maps>\",\r\n                lights_fragment_maps\r\n            )\r\n    }\r\n}","import React, { useRef, Suspense, useEffect } from 'react'\r\nimport { Canvas, useFrame, useLoader, useThree, extend } from '@react-three/fiber'\r\nimport { EffectComposer, Bloom, SMAA } from '@react-three/postprocessing'\r\nimport { EdgeDetectionMode } from 'postprocessing'\r\nimport { Environment, Stats } from \"@react-three/drei\"\r\nimport { GLTFLoader } from \"three/examples/jsm/loaders/GLTFLoader\"\r\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls'\r\nimport { RGBELoader } from 'three/examples/jsm/loaders/RGBELoader'\r\nimport { folder, useControls } from \"leva\"\r\nimport { DoubleSide, LinearFilter, MeshBasicMaterial, Vector2, WebGLCubeRenderTarget, PMREMGenerator, TextureLoader, Color } from \"three\"\r\nimport BillboardReflection from \"../billboard-reflection/BillboardReflection\"\r\n\r\nextend({ OrbitControls })\r\n\r\nfunction Controls() {\r\n  const controls = useRef()\r\n  const { camera, gl, scene } = useThree()\r\n  camera.position.y = 3\r\n  scene.background = scene.environment\r\n\r\n  useFrame(() => {\r\n    controls.current.update()\r\n  })\r\n\r\n  return <orbitControls ref={controls} args={[camera, gl.domElement]} enablePan={false} enableDamping dampingFactor={0.1} rotateSpeed={0.5} />\r\n}\r\n\r\nfunction Part() {\r\n  const { nodes } = useLoader(GLTFLoader, \"/billboard_low.glb\")\r\n\r\n  const billboard = useRef()\r\n  const billboard2 = useRef()\r\n  const ground = useRef()\r\n\r\n  const billboardReflection = new BillboardReflection()\r\n  billboardReflection.roughnessBlur = true\r\n\r\n  useFrame(() => {\r\n    const speed = 1300\r\n\r\n    billboard.current.rotation.x = -Math.PI / 2 + Math.sin(Date.now() / speed) * 0.5\r\n    billboard.current.rotation.z = Math.PI\r\n\r\n    billboard.current.position.x = Math.cos(Date.now() / speed)\r\n    billboard.current.position.y = Math.abs(Math.sin(Date.now() / speed)) * 0.5 + 1.95\r\n    billboard.current.position.z = Math.cos(Date.now() / speed) - 2\r\n\r\n    // second billboard\r\n    billboard2.current.rotation.y += 0.003\r\n    billboard2.current.rotation.y %= 2 * Math.PI\r\n    billboard2.current.position.set(2.25, 1.7, 2.5)\r\n  })\r\n\r\n  const { scene, gl } = useThree()\r\n\r\n  let renderTarget\r\n  const pmremGenerator = new PMREMGenerator(gl)\r\n  pmremGenerator.compileEquirectangularShader()\r\n\r\n  // setup controls\r\n  const [{ roughness, metalness, envMapIntensity, normalScale, color }, set] = useControls(() => {\r\n    return {\r\n    ground: folder({\r\n      roughness: {\r\n        value: nodes.ground.material.roughnessMap ? 3 : 0.1,\r\n        min: 0,\r\n        max: nodes.ground.material.roughnessMap ? 6 : 1,\r\n        step: 0.1\r\n      },\r\n      metalness: {\r\n        value: 1,\r\n        min: 0,\r\n        max: 1,\r\n        step: 0.1\r\n      },\r\n      envMapIntensity: {\r\n        value: 1,\r\n        min: 0,\r\n        max: 1,\r\n        step: 0.1\r\n      },\r\n      normalScale: {\r\n        value: 0.1,\r\n        min: 0,\r\n        max: 1,\r\n        step: 0.05\r\n      },\r\n      color: \"#eee\",\r\n      roughnessMap: {\r\n        value: true,\r\n        onChange(value){\r\n          if(!nodes.ground.material._roughnessMap){\r\n            nodes.ground.material._roughnessMap = nodes.ground.material.roughnessMap\r\n          }\r\n\r\n          nodes.ground.material.roughnessMap = value ? nodes.ground.material._roughnessMap : null\r\n          nodes.ground.material.needsUpdate = true\r\n\r\n          set({ roughness: nodes.ground.material.roughnessMap ? 3 : 0.1 })\r\n        }\r\n      },\r\n      \"sky envMap\": {\r\n        value: false,\r\n        onChange(value) {\r\n          if (!scene.background) return\r\n\r\n          const imageName = value ? \"blue_sky\" : \"garden\"\r\n\r\n          new RGBELoader().load(\"/\" + imageName + \".hdr\", tex => {\r\n            if (renderTarget) renderTarget.dispose()\r\n\r\n            renderTarget = pmremGenerator.fromEquirectangular(tex)\r\n\r\n            const envMap = renderTarget.texture\r\n            envMap.minFilter = LinearFilter\r\n\r\n            scene.background = envMap\r\n            scene.environment = envMap\r\n\r\n            tex.dispose()\r\n          })\r\n        }\r\n      }\r\n    }),\r\n    colorPatternBillboard: folder({\r\n      visible: {\r\n        value: true,\r\n        onChange(value) {\r\n          if (billboard.current) billboard.current.visible = value\r\n        }\r\n      },\r\n      opacity: {\r\n        value: 1,\r\n        min: 0,\r\n        max: 1,\r\n        step: 0.1,\r\n        onChange(value) {\r\n          if (billboard.current) billboard.current.material.opacity = value\r\n        }\r\n      },\r\n      reflection: {\r\n        value: true,\r\n        onChange(value) {\r\n          if (billboard.current._reflection) billboard.current._reflection.visible = value\r\n        }\r\n      },\r\n      color2: {\r\n        label: \"color\",\r\n        value: \"#ffffff\",\r\n        onChange(value) {\r\n          if (billboard.current) billboard.current.material.color.setStyle(value)\r\n        },\r\n      },\r\n      rayFalloff: {\r\n        value: 0,\r\n        min: 0,\r\n        max: 0.4,\r\n        step: 0.01,\r\n        onChange(value) {\r\n          if (billboard.current._reflection) billboard.current._reflection.rayFalloff = value\r\n        }\r\n      }\r\n    }),\r\n    threejsBillboard: folder({\r\n      visible2: {\r\n        label: \"visible\",\r\n        value: true,\r\n        onChange(value) {\r\n          if (billboard2.current) billboard2.current.visible = value\r\n        }\r\n      },\r\n      opacity2: {\r\n        label: \"opacity\",\r\n        value: 1,\r\n        min: 0,\r\n        max: 1,\r\n        step: 0.1,\r\n        onChange(value) {\r\n          if (billboard2.current) billboard2.current.material.opacity = value\r\n        }\r\n      },\r\n      reflection2: {\r\n        label: \"reflection\",\r\n        value: true,\r\n        onChange(value) {\r\n          if (billboard2.current._reflection) billboard2.current._reflection.visible = value\r\n        }\r\n      },\r\n      reflectionColorMultiplier2: {\r\n        label: \"reflectionColorMultiplier\",\r\n        value: 1.25,\r\n        min: 0,\r\n        max: 3,\r\n        step: 0.125,\r\n        onChange(value) {\r\n          if (billboard2.current._reflection) billboard2.current._reflection.reflectionColorMultiplier = value\r\n        },\r\n      },\r\n      rayFalloff2: {\r\n        label: \"rayFalloff\",\r\n        value: 0,\r\n        min: 0,\r\n        max: 0.4,\r\n        step: 0.01,\r\n        onChange(value) {\r\n          if (billboard2.current._reflection) billboard2.current._reflection.rayFalloff = value\r\n        }\r\n      }\r\n    }, { collapsed: true }),\r\n  }\r\n})\r\n\r\n  useEffect(() => {\r\n    billboard.current._reflection = billboardReflection.create(billboard.current, { reflectionColorMultiplier: 1.25 })\r\n    billboard2.current._reflection = billboardReflection.create(billboard2.current, { reflectionColorMultiplier: 1.25 })\r\n\r\n    ground.current.material.onBeforeCompile = shader => billboardReflection.enableReflection(shader)\r\n\r\n    const billboardMaterial = new MeshBasicMaterial({\r\n      map: nodes.billboard.material.map,\r\n      side: DoubleSide,\r\n      transparent: true,\r\n      depthWrite: false\r\n    })\r\n  \r\n    const billboard2Material = new MeshBasicMaterial({\r\n      map: nodes.billboard2.material.map,\r\n      side: DoubleSide,\r\n      transparent: true,\r\n      depthWrite: false\r\n    })\r\n\r\n    nodes.billboard.material = billboardMaterial\r\n    nodes.billboard2.material = billboard2Material\r\n  }, [])\r\n\r\n  nodes.ground.material.roughness = roughness\r\n  nodes.ground.material.metalness = metalness\r\n  nodes.ground.material.envMapIntensity = envMapIntensity\r\n  nodes.ground.material.normalScale = new Vector2(normalScale, normalScale)\r\n  nodes.ground.material.color.setStyle(color)\r\n\r\n  return (\r\n    <object3D rotation={[0, Math.PI / 2, 0]}>\r\n      <mesh ref={billboard} {...nodes.billboard} scale={[2, 2, 2]} dispose={null} />\r\n      <mesh ref={billboard2} {...nodes.billboard2} dispose={null} />\r\n      <mesh ref={ground} {...nodes.ground} dispose={null} />\r\n    </object3D>\r\n  )\r\n}\r\n\r\nexport default function App() {\r\n  return (\r\n    <>\r\n      <Canvas>\r\n        <Stats />\r\n        <pointLight position={[20, 20, 20]} intensity={0.5} />\r\n        <Suspense fallback={null}>\r\n          <Part />\r\n          <Controls />\r\n          <Environment files={\"garden.hdr\"} path={\"/\"} />\r\n          <EffectComposer multisampling={0}>\r\n            <Bloom intensity={0.3} luminanceThreshold={0.475} width={1024}></Bloom>\r\n            <SMAA edgeDetectionMode={EdgeDetectionMode.DEPTH} />\r\n          </EffectComposer>\r\n        </Suspense>\r\n      </Canvas>\r\n    </>\r\n  )\r\n}\r\n","import ReactDOM from 'react-dom'\r\nimport React from 'react'\r\nimport './demo/styles.css'\r\nimport App from './demo/App'\r\n\r\nReactDOM.render(<App />, document.getElementById('root'))\r\n"],"sourceRoot":""}